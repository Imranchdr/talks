import React, { Component, PropTypes } from 'react';

var babelHelpers = {};

babelHelpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

babelHelpers.createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

babelHelpers.extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

babelHelpers.inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

babelHelpers.possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

babelHelpers;

var Sprite = function (_ref) {
  var filename = _ref.filename;
  var x = _ref.x;
  var y = _ref.y;
  var width = _ref.width;
  var height = _ref.height;

  if (!filename) {
    return null;
  }

  var style = {
    backgroundImage: 'url(' + filename + ')',
    backgroundPosition: x * -1 + 'px ' + y * -1 + 'px',
    width: width,
    height: height
  };

  return React.createElement('div', { style: style });
};

Sprite.defaultProps = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};

Sprite.propTypes = {
  filename: PropTypes.string,
  x: PropTypes.number,
  y: PropTypes.number,
  width: PropTypes.number,
  height: PropTypes.number
};

var SpriteSheet = function (_ref) {
  var filename = _ref.filename;
  var data = _ref.data;
  var sprite = _ref.sprite;

  if (!filename || !data || !sprite) {
    return null;
  }

  var currentSprite = data[sprite];

  var spriteData = babelHelpers.extends({}, currentSprite, { filename: filename });

  return React.createElement(Sprite, spriteData);
};

SpriteSheet.propTypes = {
  filename: PropTypes.string,
  sprite: PropTypes.string,
  data: PropTypes.object
};

var AnimatedSpriteSheet = function (_Component) {
  babelHelpers.inherits(AnimatedSpriteSheet, _Component);

  function AnimatedSpriteSheet(props) {
    babelHelpers.classCallCheck(this, AnimatedSpriteSheet);

    var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AnimatedSpriteSheet).call(this, props));

    var maxFramesWidth = (_this.props.bounds.width - _this.props.bounds.x) / _this.props.frame.width;
    var maxFramesHeight = (_this.props.bounds.height - _this.props.bounds.y) / _this.props.frame.height;

    var maxFrames = maxFramesWidth * maxFramesHeight;

    _this.state = {
      frame: props.initialFrame,
      maxFrames: maxFrames
    };
    return _this;
  }

  babelHelpers.createClass(AnimatedSpriteSheet, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.timerId = setInterval(function () {
        if (_this2.props.loop && _this2.state.frame === _this2.state.maxFrames) {
          return _this2.setState({
            frame: 0
          });
        }

        return _this2.setState({
          frame: _this2.state.frame + 1
        });
      }, this.props.speed);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.timerId);
    }
  }, {
    key: 'render',
    value: function render() {
      var spriteData = {
        filename: this.props.filename,
        width: this.props.frame.width,
        height: this.props.frame.height,
        x: this.props.frame.width * this.state.frame
      };

      return React.createElement(Sprite, spriteData);
    }
  }]);
  return AnimatedSpriteSheet;
}(Component);

AnimatedSpriteSheet.propTypes = {
  filename: PropTypes.string,
  initialFrame: PropTypes.number,
  frame: PropTypes.shape({
    height: PropTypes.number,
    width: PropTypes.number
  }),
  bounds: PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number,
    width: PropTypes.number,
    height: PropTypes.number
  }),
  isPlaying: PropTypes.bool,
  loop: PropTypes.bool,
  speed: PropTypes.number
};
AnimatedSpriteSheet.defaultProps = {
  initialFrame: 0,
  frame: {
    width: 0,
    height: 0
  },
  bounds: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  isPlaying: true,
  loop: true,
  speed: 300
};

export { Sprite, SpriteSheet, AnimatedSpriteSheet };